import * as path from 'path'
import { generatorHandler } from '@prisma/generator-helper'
import type { GeneratorOptions } from '@prisma/generator-helper'
import { parseEnvValue } from '@prisma/sdk'
import fs from 'fs-extra'
import makeDir from 'make-dir'
import { run } from './generator'
import { stringToBoolean } from './generator/helpers'
import type { WriteableFileSpecs } from './generator/types'

export const generate = (options: GeneratorOptions) => {
  const { generator } = options
  const { config } = generator
  const output = parseEnvValue(generator.output!)

  const {
    removeModelUnifiedSuffix = 'Model',
    entityPrefix = '',
    entitySuffix = '',
    connectDtoPrefix = 'Connect',
    createDtoPrefix = 'Create',
    updateDtoPrefix = 'Update',
    queryDtoPrefix = 'Query',
    dtoSuffix = 'Dto',
    voPrefix = '',
    voSuffix = 'Vo',
    generateSchemaOfModule
  } = config

  const exportRelationModifierClasses = stringToBoolean(
    config.exportRelationModifierClasses,
    true
  )

  const outputToNestJSResourceStructure = stringToBoolean(
    config.outputToNestJSResourceStructure,
    false
  )

  const reExport = stringToBoolean(config.reExport, true)

  const results = run({
    removeModelUnifiedSuffix,
    output,
    dmmf: options.dmmf,
    exportRelationModifierClasses,
    outputToNestJSResourceStructure,
    entityPrefix,
    entitySuffix,
    connectDtoPrefix,
    createDtoPrefix,
    updateDtoPrefix,
    queryDtoPrefix,
    dtoSuffix,
    voPrefix,
    voSuffix,
    generateSchemaOfModule
  })

  const indexCollections: Record<string, WriteableFileSpecs> = {
    [output]: {
      fileName: `${output}/index.ts`,
      content: ''
    }
  }
  const subFolders: string[] = []
  if (reExport) {
    results.forEach(({ fileName }) => {
      const dirName = path.dirname(fileName)
      const subFolder = dirName.replace(`${output}/`, '')
      if (
        dirName !== output &&
        !dirName.match(/modules/) &&
        !subFolders.includes(subFolder)
      ) {
        subFolders.push(subFolder)
      }
      const { [dirName]: fileSpec } = indexCollections
      indexCollections[dirName] = {
        fileName: fileSpec?.fileName || path.join(dirName, 'index.ts'),
        content: [
          fileSpec?.content || '',
          `export * from './${path.basename(fileName, '.ts')}';`
        ].join('\n')
      }
    })
    subFolders.forEach(folder => {
      indexCollections[output].content += `\n export * from './${folder}'`
    })
  }

  return Promise.all(
    results
      .concat(Object.values(indexCollections))
      .map(async ({ fileName, content }) => {
        //         if (fileName.match(/modules/)) {
        //           content = `
        // /**
        //  * Generated by "npm run pregenerate-nestjs" at ${dayjs().format(
        //    'YYYY/MM/DD HH:mm:ss'
        //  )}
        //  */
        // ${content}
        // `
        //         }

        const dirname = path.dirname(fileName)
        const fname = path.basename(fileName)
        const newDirname = dirname + '.new'
        const isExistModule = fs.existsSync(fileName)
        const isExistNewModule = fs.existsSync(newDirname)
        /**
         * TODO 比较生成文件内容是否相同
         * 如果某个 module 已存在则新建 {model}.new/{model}.{service,controller,module}.ts，
         * {model}.new/* 的也存在则覆盖
         */
        const isModuleFile = fileName.match(/modules/)
        if (isModuleFile && !isExistModule && !isExistNewModule) {
          await makeDir(dirname)
          return fs.writeFile(fileName, content)
        } else if (isModuleFile && isExistModule) {
          await makeDir(newDirname)
          return fs.writeFile(`${newDirname}/${fname}`, content)
        } else {
          await makeDir(dirname)
          return fs.writeFile(fileName, content)
        }
      })
  )
}

/**
 * 入口函数，特定结构，可以自动寻找 prisma/schema.prisma 并解析
 */
generatorHandler({
  onManifest: () => ({
    defaultOutput: '../src/@generated',
    prettyName: 'NestJS RESTful API'
  }),
  onGenerate: generate
})
